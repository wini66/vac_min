<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1주차 포스팅</title>

    <!--style-->
    <link rel="stylesheet" href="g1.2.css">

</head>
<body>
    <h1>1주차 프로그래밍 기초 과제</h1>
    <hr>
    <h2 class="a">11.게임물리와 그래픽스*</h2>
    <p>
        물리 엔진(physics engine)은 강체동역학(충돌 감지 포함), 연체동역학, 유동역학과 같은 특정 물리 시스템을 최대한 시뮬레이션하는 컴퓨터 소프트웨어(SW)입니다.
        이 엔진은 컴퓨터 그래픽, 비디오 게임, 영화 분야에 주로 쓰입니다. 
        최근에는 비디오 게임에 미들웨어로 많이 이용되며 실시간으로 게임에서 발생하는 상황을 구현합니다. 
        물리엔진은 고성능 과학 시뮬레이션과 같은 특정 분야의 물리 현상을 시뮬레이션하기 위한 SW를 뜻하기도 합니다.
    </p>
    <p>
        물리엔진은 물리연산으로 가능합니다. 물리연산의 기본은 충돌 판정과 동적 시뮬레이션(특정 지점의 힘을 구현하는 것이 아니라 현실처럼 움직이는 물체의 움직임 전체를 시뮬레이션하는 것)입니다. 
        이외에 유체 시뮬레이션과 모션 컨트롤(스크립트 언어에 의해 물체의 동작을 제어하는 기능) 외부 개체를 도입해서 적용하는 등 기능이 추가돼 정밀한 물리엔진을 만들어 줍니다.
    </p>
    <p>컴퓨터 그래픽스(Computer Graphics)는 인간의 창의력과 구상력을 바탕으로 컴퓨터와 각종 소프트웨어 
        그리고 갖가지 주변기기를 이용하여 인간의 손으로 표현하기 힘든 색, 명암, 조형, 애니메이션, 영상 등과 같은 
        시각적 결과물을 생성, 조작, 출력할 수 있도록 하는데 관련된 모든 기술을 말합니다. 이를 게임분야에서도 활용할 수 있는데
        </p>
    <p> 그래픽스 프로그래머(Graphics Programmer)는 단어 그대로 해석하면 게임의 그래픽에 대한 프로그래밍을 하는 사람들입니다.
        그래픽 프로그래머가 하는 업무는 크게 두가지로
        하나는 게임 엔진의 그래픽에 관련된 기능들을 구현하는 것이고, 
        또 하나는 그 구현된 그래픽 기능들이 게임에서 잘 돌아갈 수 있도록 최적화하는 것입니다. 
        게임에 맞는 가장 적절한 그래픽을 보여줄 수 있는 가장 빠른 방법을 만들어내는 것이 중요합니다.
    </p>
<hr>
<h2 class="a">12.병렬과 동시성 프로그래밍*</h2>
<p class="cc">동시성 프로그래밍</p>
<p>: 동시에 실행되는 것처럼 보이는 방식으로 싱글코어에서 멀티 스레드를 동작시키기 위한 방식입니다.(여러개의 스레스를 번갈아 가면서 실행)</p>
<P class="cc">병렬성 프로그래밍</P>
<p>: 물리적으로 동시에 실행되는 것으로 멀티코어에서 멀티 스레드를 동작시키는 방식입니다.</p>
<p> 동시성과 병렬성 모두 비동기 동작을 구현할 수 있지만 동작 원리가 다릅니다.</p>
<p>동시성은 싱글코어와, 멀티코어에서 모두 구현이 가능하지만 병렬성은 멀티 코어에서만 구현이 가능한 것이 차이점입니다.
</p>
<img src="C:\Users\USER\Downloads\2개.png"/>
<p>위 그림은 싱글코어와 멀티코어에서 동작하는 모습을 비교하는 그림입니다.</p>
<img src="C:\Users\USER\Downloads\p.png"/>
<p>위에서는 동시적 실행과 병렬 실행과 함께 2개의 작업이 순차적으로 실행하는 모습을 보여줍니다.</p>
<hr>
<h2 class="a">13.하이퍼 쓰레딩과 문맥교환*</h2>
<p>하이퍼쓰레딩(Hyper-Threading)은 인텔 펜티엄 4에 구현한 동시 멀티쓰레딩(Simultaneous Multi-Threading, SMT)기술입니다. 
    하이퍼쓰레딩은 물리 프로세서 코어는 하나인데 프로세서가 두 개처럼, 다시 말해 두 개의 논리 프로세서로 보이게 하는 기술로
    하드웨어 수준에서 두 개 이상의 쓰레드가 동시에 실행되므로 하드웨어 쓰레드라는 표현을 씁니다.</p>
<p>현대 운영체제는 모두 멀티태스킹을 지원하는데
    일반적인 싱글코어 프로세서는 주어진 시간에 오직 하나의 쓰레드만 처리할 수 있습니다. 
    이런 하드웨어에서 운영체제가 멀티태스킹을 구현하려면 프로세서 자원을 여러 쓰레드에 돌아가면서 빌려주는 쓰레드 스케줄링이 필요합니다.
    한 쓰레드가 자신에게 주어진 시간만큼 프로세서를 썼다면 운영체제는 이 쓰레드에서 프로세서를 회수하여 다른 쓰레드에게 줍니다.
    이것을 문맥교환이라고 합니다. 
    프로세서는 한 번에 하나의 쓰레드 문맥을 처리할 수 있기에 문맥 교환을 구현하려면 명시적으로 이전 문맥을 어딘가에 저장하는데,
    이때 많은 비용이 발생합니다.
    그렇기에 무작정 쓰레드를 많이 만들어 이 쓰레드들을 바쁘게 돌리면 과다한 문맥 교환 비용으로 결코 높은 성능을 얻을 수 없습니다.</p>
<hr>
<h2 class="a">14.verse*</h2>
<p>Verse 는 에픽게임즈 가 개발한 프로그래밍 언어로, 
포크리 디바이스를 커스터마이징하는 등 포트나이트 언리얼 에디터에서 나만의 게임플레이를 제작하는 데 사용할 수 있는 언어입니다.</p>
<p>다음은 verse의 주요 설계목표입니다.</p>
<ul>
<li>간단(Simple) 하므로 초심자 프로그래머도 쉽게 학습할 수 있습니다.</li>
<li>일반적(General) 이므로 어느 유형의 코드나 데이터도 작성할 수 있습니다.</li>
<li>생산적(Productive) 이므로 팀 단위로 프로젝트를 구축, 반복, 배포하고 코드 및 콘텐츠를 통합하는 데 있어 생산성이 높습니다.</li>
<li>정적으로 검증(Statically verified) 되어 컴파일 시 최대한 많은 종류의 런타임 오류를 잡아냅니다.</li>
<li>성능이 우수(Performant) 하여 리얼타임, 오픈 월드, 멀티플레이어 게임을 만드는 데 지장이 없습니다.</li>
<li>완전(Complete) 하므로 Verse의 모든 기능을 프로그래머가 추상화할 수 있도록 지원합니다.</li>
<li>유행을 타지 않도록(Timeless) 기존 타 언어의 기능에 얽매이지 않고 오늘날 및 가까운 미래에 필요한 기능들을 위주로 설계되었습니다.</li>
</ul>
<p>위의 설계 목표들이 기반이 되어 verse의 주요기능들을 구성합니다.</p>
<ol>
    <li>강타입(Strongly typed) 언어이므로 개발 및 배포 시 오류가 발견되지 않고 넘어갈 가능성이 작으며, 정적 체크를 지원합니다.</li>
    <li>다중 패러다임(Multi-paradigm) 언어이므로 가능한 결정론적인 등 함수 프로그래밍, 오브젝트 지향 프로그래밍, 명령형 프로그래밍의 개념들을 최대한 활용합니다. 
        데이터가 기본적으로 변경 불가하며, 동일한 코드와 데이터에서는 항상 같은 결과가 나온다는 것이 하나의 예시입니다.</li>
    <li>Verse에서는 명령문과 표현식을 구분하지 않습니다. Verse에서는 모든 것이 표현식 이므로 모든 것이 결과를 가집니다</li>
    <li>실패를 컨트롤 플로로 사용합니다. Verse에서는 true / false 값을 사용해 프로그램의 흐름을 제어하는 대신, 성공 시 값을 생성하고 실패 시 값을 생성하지 않는 실패 가능 표현식 을 사용해 프로그램의 흐름을 제어합니다. 
        실패 가능 표현식은 if 표현식과 같은 실패 컨텍스트 에서만 실행할 수 있습니다.</li>
    <li>실패 컨텍스트에서 추측 실행 을 통해 커밋하지 않으면서도 특정 작업을 시도해볼 수 있습니다. 표현식이 성공하면 표현식의 이펙트가 커밋 되지만, 표현식이 실패하면 표현식이 일어나지 않았던 것처럼 표현식의 이펙트가 롤백 됩니다. 
        이 방법으로 변경 사항이 누적되는 여러 작업을 실행할 수 있지만, 어느 지점에서라도 실패하면 모든 작업의 변경 사항이 되돌려집니다.</li>
    <li>언어 수준에서 동시성을 지원하므로 동시에 여러 작업을 수행하기 위해 시스템 수준의 스레드에 의존하지 않아도 됩니다.
        컨트롤 플로를 제어하는 것과 마찬가지로, Verse에 내장된 동시성 표현식을 사용하여 타임 플로를 제어할 수 있습니다.</li>
</ol>
<hr>
<h2 class="a">15.언리얼엔진*</h2>
<p>게임에 관심이 있다면 언리얼엔진이란 말을 한번쯤 들어보셨을 것입니다. 
    기존에는 많은 개발자들이 개발엔진으로 유니티를 사용하였지만
    요즘에는 언리얼 엔진이 등장함에따라 많은 개발자들이 이를 사용하는 추세입니다.  
    언리얼 엔진은 전반적인 게임 개발 환경을 제공하는 통합형 게임 엔진으로
    '리얼타임기술'을 활용하여 현재 다양한 산업 분야에서 떠오르고 있습니다.</p>
<p>다음으로 언리얼엔진이 가지는 특징을 살펴보겠습니다.</p>
<ul>
    <li>뛰어난 그래픽, 물리 기술</li>
    <li>지속적인 업데이트</li>
    <li>다양한 기술 지원</li>
    <li>언리얼 개발자들 간의 네트워크 지원</li>
    <li>뛰어난 개발 도구</li>
    <li>무료 제공</li>
</ul>
<hr>
<h2 class="a">16.트윈모션*</h2>
<p>트윈모션은 언리얼 엔진 기반의 리얼타임 시각화 툴로서 건축, 도시 계획, 조경 전문가부터 소비재 제품, 운송 및 패션 분야에서 종사하는 디자이너까지 
    누구나 디자인 데이터로 고퀄리티 이미지, 파노라마, 표준 또는 360도 VR 영상을 빠르고 쉽게 제작할 수 있게 해줍니다.</p>
<hr>
<h2 class="a">17.photon server*</h2>
<p>Photon 은 온 프레미스 실시간 소켓 서버 이며 크로스 플랫폼 멀티 플레이어 게임 개발 프레임워크로 매우 빠르며 사용이 아주 쉽습니다.
   Photon Server의 멀티플레이어 API를 사용하여 공유 게임 세션에 많은 플레이어를 함께 참여시키고
   플랫폼 간에 연결된 플레이어 간에 실시간으로 데이터와 메시지를 동기화하여 전송합니다.</p>
<p>포톤 클라우드는 클라이언트 sdk를 사용하여 다음과 같은 유형의 게임들을 개발할 수 있습니다.</p>
<ul>
    <li>1인칭 슈팅게임</li>
    <li>레이싱 게임</li>
    <li>캐주얼 게임(실시간)</li>
    <li>비동기 및 동기 게임</li>
</ul>
<hr>
<h2 class="a">18.일렉트론*</h2>
<p>일렉트론이란 데스크톱 애플리케이션을 구축하는 도구를 말합니다.</p>
<p> Electron은 Chromium과 Node.js를 사용하여 HTML, CSS, 그리고 자바스크립트를 이용해 
    사용자가 애플리케이션을 만들수 있도록 해줍니다. Angular, React, Vue도 물론 사용가능합니다.</p>
<p> 또한 맥, 윈도우, 리눅스와 호환되며, Electron 애플리케이션은 세 개의 플랫폼에서 빌드되고 동작됩니다.</p>
<hr>
<h2 class="a">19.메모리 변조 해킹-Rust의 메모리 프로텍션*</h2>
<p>동적 할당으로 인한 메모리 누수 문제를 Rust는 안전한 메모리 사용과 성능을 위해 GC를 선택하지 않고, 
    C/C++ 보다 엄격한 컴파일러 규칙으로 메모리 누수 문제를 해결하려고 접근했습니다.
    컴파일러 규칙으로 C++ RAII 패턴(메모리를 할당한 지역을 벗어나면 메모리의 할당을 해제)을 강제로 적용했습니다.
</p>
<p>
    이때 두 포인터가 같은 데이터를 가리키고 있으므로, 같은 메모리 영역에 대해 메모리 할당 해제를 두 번 하게 되는 문제가 발생합니다. 
    이 문제를 해결하기 위해 등장한 개념이 바로 Ownership ( 소유권 )입니다.
</p>
<p>
    Rust에서는 어떤 데이터에 대한 Ownership( 소유권 )은 하나의 포인터만이 가질 수 있습니다.
    따라서, Move( 소유권 이동 )이 발생합니다.
</p>
<p>
    Rust는 소유권 개념을 통해 여러 개의 포인터가 하나의 오브젝트를 가리킴으로써 발생하는 data race를 원천적으로 차단할 수 있습니다.
</p>
<hr>
<h2 class="a">20.DLSS3*</h2>
<p>DLSS는 최근 it 업계에서 각광받고 발전되고 있는 기술인 딥러닝의 원리로 게임의 퍼포먼스를 향상시키는 기술입니다. 전용 tensor 코어 
    ai 프로세서를 사용하여 그래픽 성능을 향상시킵니다. 
    또한 DLSS는 딥 러닝 뉴럴 네트워크의 성능을 활용하여 프레임 레이트를 높이는 동시에 즐겨 하는 게임의 아름답고 또렷한 이미지를 생성해 줍니다.
</p>
<p>
    DLSS는 ai의 반복 학습 능력 기술을 통해 게임을 돌리는데 프레임당 더 적은 자원을 사용하면서 더 좋은 결과물을 출력하는 방법을 학습합니다.</p>

    <p>즉, 그래픽카드에 탑재된 텐서 코어로 GPU(그래픽카드) 가 초고해상도인 게임의 그래픽 이미지와 
    저해상도 이미지를 비교하며 반복 학습하며 이미지 퀄리티를 저해상도에서 최대한 부분적으로 상승시킬 수 있도록 딥 러닝 기술로 반복 학습을 합니다.</p>

    <p>
    그래픽카드의 해당 드라이버에 저장된 신경망은 네트워크에 저장되어, 학습 효과를 모든 그래픽카드 데이터에 공유할 수 있도록 합니다. 
    실제 저해상도 이미지를 기준과 비교하여 더 나은 결과물을 보여주는 고해상도 이미지를 게임의 화면에 생성합니다. 
    훈련된 신경망이 사용하는 입력은 게임 엔진에서 렌더링한 저해상도 별칭 이미지와 동일한 이미지에서 생성된 저해상도 모션 벡터입니다. 
    모션 벡터는 다음 프레임의 모양을 예측하기 위해 장면의 객체가 프레임에서 프레임으로 이동하는 방향을 네트워크에 송신합니다.
</p>
<p>DLSS3는 DLSS2에 비해 프레임을 높게 유지해준다는 장점이 있으나 지원하는 게임이 아직까지는 많이 없다는 게 아쉬운 점으로 보입니다.</p>

</body>
</html>